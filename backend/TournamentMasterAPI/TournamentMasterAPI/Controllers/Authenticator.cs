using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Security.Cryptography;
using System.Text;

namespace TournamentMasterAPI.Controllers
{
    public class Authenticator
    {
        private byte[] secretkey = new byte[64];
        /// <summary>
        /// Initializes a new instance of Authenticator
        /// </summary>
        public Authenticator()
        {
            using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider())
            {
                // The array is now filled with cryptographically strong random bytes.
                rng.GetBytes(secretkey);
            }
        }
        /// <summary>
        /// Signs a payload to create a token that we can cryptographically verify was generated by this Instance of Authenticator
        /// </summary>
        /// <param name="payload">The information to sign</param>
        /// <returns>The token this instance of Authenticator will vouch for</returns>
        public string createToken(string payload)
        {
            byte[] payloadBuffer = Encoding.UTF8.GetBytes(payload);
            byte[] signBuffer;
            // Initialize the keyed hash object.
            using (HMACSHA256 hmac = new HMACSHA256(secretkey))
            {
                // Compute the hash of the payload
                signBuffer = hmac.ComputeHash(payloadBuffer);
            }
            string payloadBase64 = Convert.ToBase64String(payloadBuffer);
            string signBase64 = Convert.ToBase64String(signBuffer);
            return $"{payloadBase64}:{signBase64}";
        }
        /// <summary>
        /// Verifies if the token was generated by this instance of Authenticator
        /// </summary>
        /// <param name="token">the token to verify</param>
        /// <returns>false, if not a token generated by this instance of authenticator otherwise true</returns>
        public bool verifyToken(string token)
        {
            byte[] tokenPayloadBuffer;
            byte[] tokenSignBuffer;
            byte[] authenticatorSignBuffer;

            string[] split = token.Split(':');
            if (split.Length != 2)
            {
                return false;
            }
            try
            {
                tokenPayloadBuffer = Convert.FromBase64String(split[0]);
                tokenSignBuffer = Convert.FromBase64String(split[1]);
            }
            catch (Exception)
            {
                return false;
            }
            using (HMACSHA256 hmac = new HMACSHA256(secretkey))
            {
                // Compute the hash of the payload
                authenticatorSignBuffer = hmac.ComputeHash(tokenPayloadBuffer);
            }
            // verify if the signature provided by token is one that would be created by this instance of Authenticator
            return authenticatorSignBuffer == tokenSignBuffer;
        }
    }
}